name: Backend CI/CD Pipeline

# TRIGGER: Se ejecuta en push a branches principales o en creacion de tags
on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*-dev'    # Tags que terminan en -dev van a namespace dev
      - 'v*-test'   # Tags que terminan en -test van a namespace test

env:
  DOCKER_USERNAME: facundo676
  IMAGE_NAME: backend-shop
  INFRA_REPO: Demo-Fintexa/fintexa-gitops-infra

jobs:
  # ============================================================
  # JOB 1: BUILD AND PUBLISH
  # Compila la aplicacion Spring Boot, corre tests y publica imagen Docker
  # ============================================================
  build-and-publish:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.meta.outputs.version }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
      environment: ${{ steps.environment.outputs.env }}
    
    steps:
    # FASE 1: CHECKOUT Y SETUP
    # Clona el codigo fuente y configura el entorno de Java
    - name: Checkout backend code
      uses: actions/checkout@v4
      
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    # FASE 2: CACHE DE DEPENDENCIAS MAVEN
    # Cachea las dependencias de Maven para acelerar builds futuros
    - name: Cache Maven dependencies
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
        
    # FASE 3: BUILD DE LA APLICACION SPRING BOOT
    # Ejecuta tests unitarios y compila el JAR ejecutable
    - name: Run tests
      run: mvn test
      
    - name: Build application
      run: mvn clean package -DskipTests
      
    # FASE 4: GENERACION DE TAGS Y DETERMINACION DE AMBIENTE
    # Crea tags basados en timestamp y SHA del commit
    # Detecta el ambiente de destino segun el tag de Git
    - name: Generate version tags
      id: meta
      run: |
        SHORT_SHA=${GITHUB_SHA::7}
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "version=${TIMESTAMP}-${SHORT_SHA}" >> $GITHUB_OUTPUT

    - name: Determine target environment
      id: environment
      run: |
        # Extraer el tag completo si existe
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "Tag detectado: $TAG_NAME"
          
          # Verificar si el tag termina en -dev o -test
          if [[ "$TAG_NAME" == *-dev ]]; then
            echo "env=dev" >> $GITHUB_OUTPUT
            echo "Ambiente destino: dev"
          elif [[ "$TAG_NAME" == *-test ]]; then
            echo "env=test" >> $GITHUB_OUTPUT
            echo "Ambiente destino: test"
          else
            echo "ERROR: Tag debe terminar en -dev o -test"
            exit 1
          fi
        else
          # Si no es un tag, no hacer deploy
          echo "env=none" >> $GITHUB_OUTPUT
          echo "No es un tag, saltando deployment"
        fi
        
    # FASE 5: BUILD Y PUBLICACION DE IMAGEN DOCKER
    # Hace login en DockerHub, construye la imagen y la publica con multiples tags
    - name: Log in to Docker Hub
      if: steps.environment.outputs.env != 'none'
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: Build and push Docker image
      if: steps.environment.outputs.env != 'none'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
          ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.short_sha }}

  # ============================================================
  # JOB 2: UPDATE INFRASTRUCTURE REPOSITORY
  # Actualiza el repositorio de infraestructura con el nuevo tag
  # ArgoCD detectara este cambio y desplegara automaticamente
  # ============================================================
  update-infrastructure:
    needs: build-and-publish
    runs-on: ubuntu-latest
    if: needs.build-and-publish.outputs.environment != 'none'
    
    steps:
    # FASE 1: CHECKOUT DEL REPOSITORIO DE INFRAESTRUCTURA
    # Clona el repo de infraestructura donde estan los Helm charts
    - name: Checkout infrastructure repository
      uses: actions/checkout@v4
      with:
        repository: ${{ env.INFRA_REPO }}
        token: ${{ secrets.INFRA_TOKEN }}
        path: infra
        
    # FASE 2: DETERMINACION DE ARCHIVO A ACTUALIZAR
    # Identifica cual values file modificar segun el ambiente
    - name: Determine values file to update
      id: values_file
      run: |
        ENV="${{ needs.build-and-publish.outputs.environment }}"
        VALUES_FILE="helm-charts/backend/values-${ENV}.yaml"
        echo "values_file=${VALUES_FILE}" >> $GITHUB_OUTPUT
        echo "Archivo a actualizar: ${VALUES_FILE}"
        
    # FASE 3: ACTUALIZACION DEL TAG EN VALUES FILE
    # Modifica el campo image.tag en el archivo values correspondiente
    - name: Update image tag in values file
      working-directory: infra
      run: |
        VALUES_FILE="${{ steps.values_file.outputs.values_file }}"
        NEW_TAG="${{ needs.build-and-publish.outputs.version }}"
        
        echo "Actualizando $VALUES_FILE con tag: $NEW_TAG"
        
        # Verificar que el archivo existe
        if [ ! -f "$VALUES_FILE" ]; then
          echo "ERROR: Archivo $VALUES_FILE no existe"
          exit 1
        fi
        
        # Actualizar el tag usando sed
        sed -i "s|tag: .*|tag: \"$NEW_TAG\"|g" $VALUES_FILE
        
        # Mostrar el cambio
        echo "Cambios realizados:"
        git diff $VALUES_FILE
        
    # FASE 4: COMMIT Y PUSH AL REPOSITORIO DE INFRAESTRUCTURA
    # Hace commit de los cambios y los pushea a Git
    # ArgoCD detectara este cambio en los proximos 3 minutos
    - name: Commit and push changes
      working-directory: infra
      run: |
        ENV="${{ needs.build-and-publish.outputs.environment }}"
        VERSION="${{ needs.build-and-publish.outputs.version }}"
        
        # Configurar Git
        git config --local user.email "ci-bot@github.com"
        git config --local user.name "CI Bot"
        
        # Verificar si hay cambios
        if git diff --quiet; then
          echo "No hay cambios para commitear"
          exit 0
        fi
        
        # Mostrar estado
        echo "Archivos modificados:"
        git diff --name-only
        
        # Commit y push
        git add .
        git commit -m "Update backend ($ENV) to $VERSION

Automated update by CI pipeline
- Environment: $ENV
- Image tag: $VERSION
- Triggered by: ${{ github.sha }}"
        
        git push
        
        echo "Cambios pusheados exitosamente"
        echo "ArgoCD sincronizara automaticamente en los proximos 3 minutos"
